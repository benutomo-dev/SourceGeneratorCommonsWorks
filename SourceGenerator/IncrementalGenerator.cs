using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using SourceGeneratorCommons;
using SourceGeneratorCommons.Collections.Generic;
using SourceGeneratorCommons.CSharp.Declarations;
using System.Collections.Immutable;

namespace SourceGenerator;

[Generator(LanguageNames.CSharp)]
public class IncrementalGenerator : IIncrementalGenerator
{
    internal List<(CsTypeDeclaration, EquatableArray<CsMethod>)> list = new List<(CsTypeDeclaration, EquatableArray<CsMethod>)>();

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(context =>
        {
            using var sourceBuilder = new SourceBuilder(context, "PostInitializationOutput.cs");

            var attributeTypeDefinition = new CsClass(
                new CsNameSpace("System"),
                "Attribute",
                classModifier: CsClassModifier.Sealed
            );

            var attributeTypeReference = new CsTypeReference(attributeTypeDefinition);

            var sampleTypeDefinition = new CsClass(
                new CsNameSpace("SrcGen"),
                "SourceGenAttribute",
                baseType: attributeTypeReference,
                accessibility: CsAccessibility.Internal
            );

            using (sourceBuilder.BeginTypeDefinitionBlock(sampleTypeDefinition))
            {
                sourceBuilder.AppendLineWithFirstIndent($"// this is sample.");
            }


            var enumTypeDefinition = new CsEnum(
                new CsNameSpace("System"),
                "Enum64",
                CsAccessibility.Internal,
                CsEnumUnderlyingType.UInt64);

            using (sourceBuilder.BeginTypeDefinitionBlock(enumTypeDefinition))
            {
                sourceBuilder.AppendLineWithFirstIndent($"// this is enum sample.");
            }

            sourceBuilder.Commit();
        });

        static bool predicate(SyntaxNode node, CancellationToken cancellationToken)
        {
            if (node is not TypeDeclarationSyntax typeDeclarationSyntax)
                return false;

            return typeDeclarationSyntax.Modifiers.Any(SyntaxKind.PartialKeyword);
        }

        static INamedTypeSymbol? transform(GeneratorSyntaxContext context, CancellationToken cancellationToken)
        {
            var typeDeclarationSyntax = (TypeDeclarationSyntax)context.Node;

            var typeSymbol = context.SemanticModel.GetDeclaredSymbol(typeDeclarationSyntax, cancellationToken);

            return typeSymbol;
        }

        var csDeclarationProvider = context.CreateCsDeclarationProvider();

        var source = context.SyntaxProvider
            .CreateSyntaxProvider(predicate, transform)
            .Collect()
            .SelectMany((typeSymbol, cancellationToken) =>
            {
                return typeSymbol
                    .Where(v => v is not null)
                    .Select(v => v!)
                    .Distinct<INamedTypeSymbol>(SymbolEqualityComparer.Default);
            })
            .Combine(csDeclarationProvider)
            .Select((v, cancellationToken) =>
            {
                var (typeSymbol, context) = v;

                var typeDefinition = context.GetTypeDeclaration(typeSymbol);
                var methodDefinitions = typeSymbol.GetMembers()
                    .OfType<IMethodSymbol>()
                    .Where(v => v.IsPartialDefinition)
                    .Select(context.GetMethodDeclaration)
                    .ToImmutableArray()
                    .ToEquatableArray();

                list.Add((typeDefinition, methodDefinitions));

                return (typeDefinition, methodDefinitions);
            })
            .WithTrackingName("source");

        context.RegisterSourceOutput(source, (context, source) =>
        {
            var hintName = $"{source.typeDefinition.MakeStandardHintName()}.cs";

            var builder = new SourceBuilder(context, hintName);

            builder.AppendLine(SourceBuilder.AutoGeneratedComment);

            using (builder.BeginTypeDefinitionBlock(source.typeDefinition, new TypeDefinitionBlockOptions { TypeDeclarationLineTail = $" // This is source generated type." }))
            {
                foreach (var methodDefinitionInfo in source.methodDefinitions.Values)
                {
                    using (builder.BeginMethodDefinitionBlock(methodDefinitionInfo, methodDeclarationLineTail: $" // This is source generated method."))
                    {
                        if (!methodDefinitionInfo.IsVoidMethod)
                        {
                            builder.AppendLineWithFirstIndent("return default;");
                        }
                    }
                }
            }
                
            builder.Commit();
        });
    }
}
