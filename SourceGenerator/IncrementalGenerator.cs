using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using SourceGeneratorCommons;
using System.Collections.Immutable;

namespace SourceGenerator;

[Generator(LanguageNames.CSharp)]
public class IncrementalGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(context =>
        {
            using var sourceBuilder = new SourceBuilder(context, "PostInitializationOutput.cs");

            var sampleTypeDefinition = new TypeDefinitionInfo(
                new TypeDefinitionInfo(
                    new NameSpaceInfo("Gen.Namespace"),
                    "OuterClass",
                    TypeCategory.Class,
                    ImmutableArray.Create(new GenericTypeParam("T1"), new GenericTypeParam("T2", new GenericTypeConstraints())),
                    IsStatic: true,
                    IsReadOnly: false,
                    IsRef: false
                ),
                "InnerClass",
                TypeCategory.Struct
            );

            using (sourceBuilder.BeginTypeDefinitionBlock(sampleTypeDefinition))
            {
                sourceBuilder.AppendLineWithFirstIndent($"// this is sample.");
            }

            sourceBuilder.Commit();
        });

        static bool predicate(SyntaxNode node, CancellationToken cancellationToken)
        {
            if (node is not TypeDeclarationSyntax typeDeclarationSyntax)
                return false;

            return typeDeclarationSyntax.Modifiers.Any(v => v.Text == "partial");
        }

        static INamedTypeSymbol? transform(GeneratorSyntaxContext context, CancellationToken cancellationToken)
        {
            var typeDeclarationSyntax = (TypeDeclarationSyntax)context.Node;

            var typeSymbol = (INamedTypeSymbol?)context.SemanticModel.GetDeclaredSymbol(typeDeclarationSyntax, cancellationToken);

            return typeSymbol;
        }

        var source = context.SyntaxProvider
            .CreateSyntaxProvider(predicate, transform)
            .Collect()
            .SelectMany((typeSymbol, cancellationToken) =>
            {
                return typeSymbol
                    .Where(v => v is not null)
                    .Select(v => v!)
                    .Distinct<INamedTypeSymbol>(SymbolEqualityComparer.Default);
            })
            .Select((typeSymbol, cancellationToken) =>
            {
                var typeDefinition = typeSymbol.BuildTypeDefinitionInfo().DefinitionInfo;
                var methodDefinitions = typeSymbol.GetMembers()
                    .OfType<IMethodSymbol>()
                    .Where(v => v.IsPartialDefinition)
                    .Select(v => v.BuildMethodDefinitionInfo(cancellationToken))
                    .ToImmutableArray()
                    .ToEquatableArray();
                return (typeDefinition, methodDefinitions);
            });

        context.RegisterSourceOutput(source, (context, source) =>
        {
            var hintName = $"{source.typeDefinition.MakeStandardHintName()}.cs";

            var builder = new SourceBuilder(context, hintName);

            //builder.AppendLine("// <auto-generated/>");

            using (builder.BeginTypeDefinitionBlock(source.typeDefinition, $" // This is source generated type."))
            {
                foreach (var methodDefinitionInfo in source.methodDefinitions.Values)
                {
                    using (builder.BeginMethodDefinitionBlock(methodDefinitionInfo, $" // This is source generated method."))
                    {
                        if (!methodDefinitionInfo.IsVoidMethod)
                        {
                            builder.AppendLineWithFirstIndent("return default;");
                        }
                    }
                }
            }
                
            builder.Commit();
        });
    }
}
